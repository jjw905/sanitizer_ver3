import os
import re
from typing import Dict, List, Tuple
from PyPDF2 import PdfReader
from PyPDF2.generic import IndirectObject
from oletools.olevba import VBA_Parser


class MalwareClassifier:
    """악성코드 유형 분류기"""

    def __init__(self):
        # 악성코드 유형별 시그니처 패턴
        self.malware_patterns = {
            # 문서 매크로 기반 악성코드
            'Macro Dropper': {
                'extensions': ['.docm', '.docx', '.xlsm', '.xlsx', '.pptm', '.pptx'],
                'keywords': ['auto_open', 'workbook_open', 'document_open', 'shell', 'createobject'],
                'vba_patterns': [
                    r'shell\s*\(',
                    r'createobject\s*\(',
                    r'wscript\.',
                    r'environ\s*\(',
                    r'application\.run'
                ]
            },

            # 이메일 첨부 악성코드
            'Email Trojan': {
                'extensions': ['.docx', '.pdf', '.xlsx'],
                'keywords': ['invoice', 'payment', 'order', 'receipt', 'statement'],
                'filename_patterns': [
                    r'invoice.*\.(docx?|pdf)',
                    r'payment.*\.(xlsx?|pdf)',
                    r'order.*\.(docx?|pdf)'
                ]
            },

            # PDF JavaScript 악성코드
            'PDF Exploit': {
                'extensions': ['.pdf'],
                'keywords': ['javascript', 'js', 'openaction', 'launch'],
                'pdf_patterns': [
                    '/JavaScript',
                    '/JS',
                    '/OpenAction',
                    '/Launch'
                ]
            },

            # 다운로더/드로퍼
            'Downloader': {
                'extensions': ['.docx', '.docm', '.xlsx', '.xlsm', '.pdf'],
                'keywords': ['urlmon', 'wininet', 'downloadfile', 'http', 'https'],
                'patterns': [
                    r'http[s]?://.*',
                    r'urlmon\.dll',
                    r'wininet\.dll',
                    r'downloadfile'
                ]
            },

            # 뱅킹 트로이목마
            'Banking Trojan': {
                'extensions': ['.docx', '.docm', '.xlsx', '.xlsm'],
                'keywords': ['bank', 'banking', 'finance', 'payment', 'account'],
                'filename_patterns': [
                    r'bank.*statement',
                    r'account.*info',
                    r'payment.*confirmation'
                ]
            },

            # 랜섬웨어 관련
            'Ransomware Dropper': {
                'extensions': ['.docx', '.docm', '.xlsx', '.xlsm'],
                'keywords': ['encrypt', 'decrypt', 'ransom', 'bitcoin', 'crypto'],
                'vba_patterns': [
                    r'encrypt',
                    r'decrypt',
                    r'bitcoin',
                    r'ransom'
                ]
            },

            # 한글 문서 악성코드
            'HWP Exploit': {
                'extensions': ['.hwp', '.hwpx', '.hwpml'],
                'keywords': ['shell', 'cmd', 'javascript', 'script'],
                'patterns': [
                    b'Shell',
                    b'cmd',
                    b'javascript',
                    b'script'
                ]
            },

            # APT 공격 문서
            'APT Document': {
                'extensions': ['.docx', '.docm', '.xlsx', '.xlsm', '.pdf'],
                'keywords': ['confidential', 'secret', 'classified', 'internal'],
                'filename_patterns': [
                    r'confidential.*',
                    r'secret.*',
                    r'classified.*',
                    r'internal.*'
                ]
            }
        }

        # ... (MalwareClassifier 클래스 내부) ...
        # 알려진 악성코드  시그니처
        self.malware_families = {
            'Emotet': ['emotet', 'epoch', 'banking', 'trojan', 'geodo'],  # 새로운 별칭 추가
            'Trickbot': ['trickbot', 'trick', 'banking', 'modular'],
            'QakBot': ['qakbot', 'qbot', 'banking', 'worm'],
            'FormBook': ['formbook', 'infostealer', 'keylogger'],
            'Agent Tesla': ['agent tesla', 'agenttesla', 'infostealer'],
            'Lokibot': ['lokibot', 'loki', 'infostealer'],
            'NanoCore': ['nanocore', 'rat', 'remote access'],
            'Dridex': ['dridex', 'bugat', 'banking'],
            'IcedID': ['icedid', 'bokbot', 'banking'],
            'Ursnif': ['ursnif', 'gozi', 'isfb', 'banking'],
            'SocGholish': ['socgholish', 'fakereport', 'fakeupdate'],
            'DarkGate': ['darkgate', 'autoit', 'loader']
        }

    # ... (이하 생략) ...

    def classify_malware(self, file_path: str) -> str:
        """악성코드 유형 분류"""
        try:
            file_name = os.path.basename(file_path).lower()
            file_ext = os.path.splitext(file_path)[1].lower()

            # 1. 파일명 기반 가족 분류
            family_result = self._classify_by_family(file_name)
            if family_result != "Unknown":
                return family_result

            # 2. 파일 확장자별 상세 분석
            if file_ext in ['.docx', '.docm', '.xlsx', '.xlsm', '.pptx', '.pptm']:
                return self._classify_office_document(file_path, file_name)
            elif file_ext == '.pdf':
                return self._classify_pdf_document(file_path, file_name)
            elif file_ext in ['.hwp', '.hwpx', '.hwpml']:
                return self._classify_hwp_document(file_path, file_name)
            else:
                return "Unknown Document Type"

        except Exception as e:
            return f"분류 오류: {str(e)}"

    def _classify_by_family(self, file_name: str) -> str:
        """알려진 악성코드 가족으로 분류"""
        for family, keywords in self.malware_families.items():
            for keyword in keywords:
                if keyword in file_name:
                    return f"{family} 가족"
        return "Unknown"

    def _classify_office_document(self, file_path: str, file_name: str) -> str:
        """Office 문서 악성코드 분류"""
        classification_scores = {}

        try:
            # VBA 매크로 분석
            vba_parser = VBA_Parser(file_path)
            has_macro = vba_parser.detect_vba_macros()

            if has_macro:
                vba_code = ""
                try:
                    for (filename, stream_path, vba_filename, vba_code_chunk) in vba_parser.extract_macros():
                        vba_code += vba_code_chunk.lower()
                except:
                    pass

                # 각 유형별 점수 계산
                for malware_type, patterns in self.malware_patterns.items():
                    if os.path.splitext(file_path)[1].lower() not in patterns.get('extensions', []):
                        continue

                    score = 0

                    # 키워드 매칭
                    for keyword in patterns.get('keywords', []):
                        if keyword in vba_code:
                            score += 2

                    # VBA 패턴 매칭
                    for pattern in patterns.get('vba_patterns', []):
                        if re.search(pattern, vba_code, re.IGNORECASE):
                            score += 3

                    # 파일명 패턴 매칭
                    for pattern in patterns.get('filename_patterns', []):
                        if re.search(pattern, file_name, re.IGNORECASE):
                            score += 2

                    if score > 0:
                        classification_scores[malware_type] = score

                # 다운로더 패턴 특별 검사
                downloader_patterns = ['urlmon', 'wininet', 'http', 'download', 'internet']
                downloader_score = sum(1 for pattern in downloader_patterns if pattern in vba_code)
                if downloader_score >= 2:
                    classification_scores['Downloader'] = classification_scores.get('Downloader', 0) + downloader_score

                # 뱅킹 관련 키워드 검사
                banking_keywords = ['bank', 'account', 'payment', 'finance', 'invoice']
                banking_score = sum(1 for keyword in banking_keywords if keyword in file_name)
                if banking_score >= 1:
                    classification_scores['Banking Trojan'] = classification_scores.get('Banking Trojan',
                                                                                        0) + banking_score

            else:
                # 매크로가 없는 경우 파일명으로만 분류
                if any(keyword in file_name for keyword in ['invoice', 'payment', 'statement']):
                    classification_scores['Email Trojan'] = 1
                elif any(keyword in file_name for keyword in ['confidential', 'secret', 'internal']):
                    classification_scores['APT Document'] = 1

        except Exception as e:
            return f"Office 분석 오류: {str(e)}"

        # 최고 점수 유형 반환
        if classification_scores:
            best_type = max(classification_scores.items(), key=lambda x: x[1])
            return f"{best_type[0]} (신뢰도: {best_type[1]})"
        else:
            return "매크로 기반 악성코드 (일반)" if has_macro else "정상 문서로 추정"

    def _classify_pdf_document(self, file_path: str, file_name: str) -> str:
        """PDF 문서 악성코드 분류"""
        classification_scores = {}

        try:
            reader = PdfReader(file_path)

            # JavaScript 존재 확인
            has_javascript = False
            has_openaction = False
            has_launch = False

            root = reader.trailer.get("/Root", {})
            if isinstance(root, IndirectObject):
                root = root.get_object()

            # PDF 구조 분석
            pdf_content = str(root).lower()

            if '/javascript' in pdf_content or '/js' in pdf_content:
                has_javascript = True
                classification_scores['PDF Exploit'] = classification_scores.get('PDF Exploit', 0) + 3

            if '/openaction' in pdf_content:
                has_openaction = True
                classification_scores['PDF Exploit'] = classification_scores.get('PDF Exploit', 0) + 2

            if '/launch' in pdf_content:
                has_launch = True
                classification_scores['PDF Exploit'] = classification_scores.get('PDF Exploit', 0) + 2

            # 파일명 기반 분류
            if any(keyword in file_name for keyword in ['invoice', 'payment', 'statement']):
                classification_scores['Email Trojan'] = classification_scores.get('Email Trojan', 0) + 2

            if any(keyword in file_name for keyword in ['confidential', 'secret', 'classified']):
                classification_scores['APT Document'] = classification_scores.get('APT Document', 0) + 2

            # 다운로더 패턴 검사
            downloader_keywords = ['http', 'download', 'url']
            if any(keyword in pdf_content for keyword in downloader_keywords):
                classification_scores['Downloader'] = classification_scores.get('Downloader', 0) + 1

        except Exception as e:
            return f"PDF 분석 오류: {str(e)}"

        # 결과 반환
        if classification_scores:
            best_type = max(classification_scores.items(), key=lambda x: x[1])
            return f"{best_type[0]} (신뢰도: {best_type[1]})"
        else:
            return "정상 PDF로 추정"

    def _classify_hwp_document(self, file_path: str, file_name: str) -> str:
        """HWP 문서 악성코드 분류"""
        classification_scores = {}

        try:
            with open(file_path, 'rb') as f:
                content = f.read()

            # HWP 특화 패턴 검사
            hwp_patterns = {
                'Shell': 3,
                'cmd': 2,
                'javascript': 2,
                'script': 1,
                'urlmon': 2,
                'http': 1
            }

            for pattern_bytes, score in hwp_patterns.items():
                pattern = pattern_bytes.encode() if isinstance(pattern_bytes, str) else pattern_bytes
                if pattern in content:
                    classification_scores['HWP Exploit'] = classification_scores.get('HWP Exploit', 0) + score

            # 파일명 기반 분류
            if any(keyword in file_name for keyword in ['공문', '보고서', '계획서', '제안서']):
                classification_scores['APT Document'] = classification_scores.get('APT Document', 0) + 1

            if any(keyword in file_name for keyword in ['긴급', '중요', '기밀']):
                classification_scores['APT Document'] = classification_scores.get('APT Document', 0) + 2

        except Exception as e:
            return f"HWP 분석 오류: {str(e)}"

        # 결과 반환
        if classification_scores:
            best_type = max(classification_scores.items(), key=lambda x: x[1])
            return f"{best_type[0]} (신뢰도: {best_type[1]})"
        else:
            return "정상 HWP로 추정"

    def get_malware_info(self, malware_type: str) -> Dict[str, str]:
        """악성코드 유형별 상세 정보 제공"""
        info_database = {
            'Macro Dropper': {
                'description': '매크로를 이용해 추가 악성코드를 다운로드하거나 실행하는 악성코드',
                'risk_level': '높음',
                'common_targets': 'Office 사용자',
                'prevention': '매크로 비활성화, 최신 보안 업데이트 적용'
            },
            'Email Trojan': {
                'description': '이메일 첨부파일을 통해 유포되는 트로이목마',
                'risk_level': '높음',
                'common_targets': '일반 사용자',
                'prevention': '의심스러운 첨부파일 실행 금지'
            },
            'PDF Exploit': {
                'description': 'PDF 뷰어의 취약점을 악용하는 악성코드',
                'risk_level': '중간',
                'common_targets': 'PDF 뷰어 사용자',
                'prevention': 'PDF 뷰어 최신 업데이트, JavaScript 비활성화'
            },
            'Banking Trojan': {
                'description': '온라인 뱅킹 정보를 탈취하는 악성코드',
                'risk_level': '매우 높음',
                'common_targets': '온라인 뱅킹 사용자',
                'prevention': '공인인증서 보안, 의심스러운 뱅킹 관련 문서 주의'
            },
            'HWP Exploit': {
                'description': '한글 워드프로세서의 취약점을 악용하는 악성코드',
                'risk_level': '높음',
                'common_targets': '한글 프로그램 사용자',
                'prevention': '한글 프로그램 최신 업데이트, 의심 문서 실행 금지'
            },
            'APT Document': {
                'description': '지속적 지능형 위협(APT) 공격에 사용되는 문서',
                'risk_level': '매우 높음',
                'common_targets': '기업, 정부기관',
                'prevention': '보안 솔루션 강화, 직원 보안 교육'
            }
        }

        # 악성코드 타입에서 실제 타입명 추출
        base_type = malware_type.split(' (')[0]

        return info_database.get(base_type, {
            'description': '알 수 없는 악성코드 유형',
            'risk_level': '알 수 없음',
            'common_targets': '알 수 없음',
            'prevention': '일반적인 보안 수칙 준수'
        })

    def generate_detailed_report(self, file_path: str) -> str:
        """상세 악성코드 분석 보고서 생성"""
        file_name = os.path.basename(file_path)
        malware_type = self.classify_malware(file_path)
        malware_info = self.get_malware_info(malware_type)

        report = f"""
=== 악성코드 분석 보고서 ===

파일명: {file_name}
분류 결과: {malware_type}

[위험도 평가]
- 위험 수준: {malware_info['risk_level']}
- 주요 대상: {malware_info['common_targets']}

[설명]
{malware_info['description']}

[대응 방안]
{malware_info['prevention']}

[권장 조치]
1. 해당 파일을 즉시 격리
2. 시스템 전체 검사 실시
3. 관련 보안 패치 적용
4. 사용자 보안 교육 강화
"""
        return report